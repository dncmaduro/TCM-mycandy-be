// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===================== ENUMS =====================
 */
enum UserStatus {
  pending
  active
  rejected
  suspended
}

enum MemberRole {
  owner
  admin
  member
  guest
}

enum TaskStatus {
  todo
  in_progress
  done
  blocked
}

enum TaskPriority {
  low
  medium
  high
  urgent
}

enum AttendeeResp {
  needsAction
  accepted
  declined
  tentative
}

enum DeptMemberRole {
  manager
  member
}

enum NotificationType {
  user_signup_pending
  user_signup_approved
  user_signup_rejected
  task_assigned
  task_commented
  event_invite
  event_updated
}

/**
 * ===================== USERS / AUTH =====================
 */
model User {
  id             String     @id @default(uuid())
  email          String     @unique @db.Citext
  emailVerified  DateTime?
  passwordHash   String?
  name           String?
  avatarUrl      String?
  status         UserStatus @default(pending)
  approvedById   String?
  approvedAt     DateTime?
  rejectedReason String?
  createdAt      DateTime   @default(now())

  // relations
  oauthAccounts    AccountsOauth[]
  sessions         Session[]
  approvalsActed   UserApproval[]     @relation("Approver")
  approvalsTarget  UserApproval[]     @relation("Target")
  memberships      Membership[]
  managedDepts     Department[]       @relation("DeptManager")
  deptMemberships  DepartmentMember[]
  projectsCreated  Project[]          @relation("ProjectCreator")
  tasksAssigned    Task[]             @relation("AssignedTasks")
  tasksCreated     Task[]             @relation("TaskCreator")
  calendarsCreated Calendar[]         @relation("CalendarCreator")
  eventsCreated    Event[]            @relation("EventCreator")
  notifications    Notification[]     @relation("NotiRecipient")
  TaskComment      TaskComment[]
  EventAttendee    EventAttendee[]
  GoogleCalendar   GoogleCalendar[]

  @@index([status])
}

model AccountsOauth {
  id                String    @id @default(uuid())
  userId            String
  provider          String
  providerAccountId String
  accessToken       String?
  refreshToken      String?
  expiresAt         DateTime?
  scope             String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id        String   @id @default(uuid())
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserApproval {
  id           String   @id @default(uuid())
  targetUserId String
  action       String // 'approve' | 'reject' (validate ở app)
  reason       String?
  actedById    String
  actedAt      DateTime @default(now())

  targetUser User @relation("Target", fields: [targetUserId], references: [id], onDelete: Cascade)
  actedBy    User @relation("Approver", fields: [actedById], references: [id], onDelete: Restrict)

  @@index([actedAt])
}

/**
 * ===================== ORGS / MEMBERS =====================
 */
model Organization {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now())

  memberships   Membership[]
  projects      Project[]
  calendars     Calendar[]
  departments   Department[]
  notifications Notification[]
  Task          Task[]
  SyncOutbox    SyncOutbox[]
}

model Membership {
  orgId  String
  userId String
  role   MemberRole

  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([orgId, userId])
}

/**
 * ===================== DEPARTMENTS (hierarchy) =====================
 */
model Department {
  id        String   @id @default(uuid())
  orgId     String
  name      String
  code      String?
  parentId  String?
  path      String? // ltree lưu dạng string; subtree query = $queryRaw
  managerId String?
  createdAt DateTime @default(now())

  org      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  parent   Department?  @relation("DeptParent", fields: [parentId], references: [id], onDelete: SetNull)
  children Department[] @relation("DeptParent")
  manager  User?        @relation("DeptManager", fields: [managerId], references: [id], onDelete: SetNull)

  members DepartmentMember[]

  @@unique([orgId, name])
  @@index([orgId])
  @@index([parentId])
}

model DepartmentMember {
  departmentId String
  userId       String
  role         DeptMemberRole @default(member)
  joinedAt     DateTime       @default(now())

  department Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([departmentId, userId])
}

/**
 * ===================== PROJECTS / TASKS =====================
 */
model Project {
  id          String   @id @default(uuid())
  orgId       String
  name        String
  description String?
  createdBy   String
  createdAt   DateTime @default(now())

  org     Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  creator User         @relation("ProjectCreator", fields: [createdBy], references: [id], onDelete: Restrict)
  tasks   Task[]

  @@index([orgId])
}

model Task {
  id              String        @id @default(uuid())
  orgId           String
  projectId       String?
  title           String
  description     String?
  status          TaskStatus    @default(todo)
  priority        TaskPriority?
  assigneeId      String?
  dueAt           DateTime?
  startAt         DateTime?
  estimateMinutes Int?
  createdBy       String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  version         Int           @default(1)

  org      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  project  Project?     @relation(fields: [projectId], references: [id], onDelete: SetNull)
  assignee User?        @relation("AssignedTasks", fields: [assigneeId], references: [id], onDelete: SetNull)
  creator  User         @relation("TaskCreator", fields: [createdBy], references: [id], onDelete: Restrict)

  checklists TaskChecklist[]
  comments   TaskComment[]
  taskEvents TaskEventLink[]

  @@index([orgId, projectId])
  @@index([orgId, status, dueAt])
  @@index([assigneeId, dueAt])
}

model TaskChecklist {
  id      String  @id @default(uuid())
  taskId  String
  content String
  isDone  Boolean @default(false)
  idx     Int     @default(0)

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId, isDone])
}

model TaskComment {
  id        String   @id @default(uuid())
  taskId    String
  authorId  String
  body      String
  createdAt DateTime @default(now())

  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  author User @relation(fields: [authorId], references: [id], onDelete: Restrict)

  @@index([taskId, createdAt])
}

/**
 * ===================== CALENDARS / EVENTS =====================
 */
model Calendar {
  id        String   @id @default(uuid())
  orgId     String
  name      String
  timeZone  String?
  isPrimary Boolean  @default(false)
  createdBy String
  createdAt DateTime @default(now())

  org     Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  creator User         @relation("CalendarCreator", fields: [createdBy], references: [id], onDelete: Restrict)
  events  Event[]
  // NOTE: unique "one primary per org" phải enforce bằng migration SQL hoặc logic ứng dụng

  @@index([orgId])
}

model Event {
  id          String   @id @default(uuid())
  calendarId  String
  title       String
  description String?
  location    String?
  startsAt    DateTime
  endsAt      DateTime
  allDay      Boolean  @default(false)
  createdBy   String
  updatedAt   DateTime @updatedAt
  version     Int      @default(1)

  calendar Calendar @relation(fields: [calendarId], references: [id], onDelete: Cascade)
  creator  User     @relation("EventCreator", fields: [createdBy], references: [id], onDelete: Restrict)

  attendees       EventAttendee[]
  taskEventLinks  TaskEventLink[]
  GoogleEventLink GoogleEventLink[]

  @@index([calendarId, startsAt, endsAt])
}

model EventAttendee {
  // composite PK: (eventId, key) nhưng Prisma không cho PK với COALESCE;
  // ta dùng surrogate id + unique logic ở app.
  id             String        @id @default(uuid())
  eventId        String
  userId         String?
  email          String?       @db.Citext
  responseStatus AttendeeResp?

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([eventId])
}

model TaskEventLink {
  taskId  String
  eventId String

  task  Task  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([taskId, eventId])
}

/**
 * ===================== GOOGLE CAL SYNC =====================
 */
model GoogleCalendar {
  id               String    @id @default(uuid())
  userId           String
  googleCalendarId String
  summary          String?
  timeZone         String?
  color            String?
  syncToken        String?
  channelId        String?
  resourceId       String?
  channelExpireAt  DateTime?
  lastSyncedAt     DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  events GoogleEventLink[]

  @@unique([userId, googleCalendarId])
}

model GoogleEventLink {
  eventId             String
  googleCalendarIdRef String
  googleEventId       String
  googleEtag          String?
  lastPushedAt        DateTime?
  lastPulledAt        DateTime?

  event          Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  googleCalendar GoogleCalendar @relation(fields: [googleCalendarIdRef], references: [id], onDelete: Cascade)

  @@id([eventId, googleCalendarIdRef])
  @@unique([googleCalendarIdRef, googleEventId])
}

/**
 * ===================== NOTIFICATIONS =====================
 */
model Notification {
  id          String           @id @default(uuid())
  orgId       String?
  recipientId String
  type        NotificationType
  title       String?
  body        String?
  data        Json?
  isRead      Boolean          @default(false)
  createdAt   DateTime         @default(now())
  readAt      DateTime?

  org       Organization? @relation(fields: [orgId], references: [id], onDelete: SetNull)
  recipient User          @relation("NotiRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([recipientId, isRead, createdAt])
  @@index([orgId, createdAt])
}

/**
 * ===================== OUTBOX / LOGS =====================
 */
model SyncOutbox {
  id          BigInt    @id @default(autoincrement())
  orgId       String?
  kind        String // 'event.create' | 'event.update' | ...
  payload     Json
  dedupeKey   String?   @unique
  createdAt   DateTime  @default(now())
  processedAt DateTime?

  org Organization? @relation(fields: [orgId], references: [id], onDelete: SetNull)

  @@index([kind])
}

model SyncLog {
  id         BigInt   @id @default(autoincrement())
  source     String // 'google->local' | 'local->google'
  entityType String // 'calendar' | 'event' | 'task' | ...
  entityId   String?
  externalId String?
  status     String // 'ok' | 'retry' | 'failed'
  message    String?
  occurredAt DateTime @default(now())

  @@index([occurredAt])
}
